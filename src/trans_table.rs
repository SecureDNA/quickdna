use crate::{
    errors::TranslationError,
    nucleotide::{Codon, Nucleotide},
};

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum TranslationTable {
    Ncbi1,
    Ncbi2,
    Ncbi3,
    Ncbi4,
    Ncbi5,
    Ncbi6,
    Ncbi7,
    Ncbi8,
    Ncbi9,
    Ncbi10,
    Ncbi11,
    Ncbi12,
    Ncbi13,
    Ncbi14,
    Ncbi15,
    Ncbi16,
    // tables 17-20 are not assigned
    Ncbi21,
    Ncbi22,
    Ncbi23,
    Ncbi24,
    Ncbi25,
    Ncbi26,
    Ncbi27,
    Ncbi28,
    Ncbi29,
    Ncbi30,
    Ncbi31,
    Ncbi32,
    Ncbi33,
}

#[repr(transparent)]
pub struct CodonIdx(usize);

impl From<[Nucleotide; 3]> for CodonIdx {
    fn from(value: [Nucleotide; 3]) -> Self {
        Self((value[0] as usize) << 6 | (value[1] as usize) << 3 | (value[2] as usize))
    }
}

impl From<Codon> for CodonIdx {
    fn from(c: Codon) -> Self {
        c.0.into()
    }
}

impl From<CodonIdx> for usize {
    fn from(c: CodonIdx) -> Self {
        c.0
    }
}

impl TranslationTable {
    /// There are really only 125 possible codons (len(ATCGN)^3), but since codons take up
    /// 3 bits, the maximum codon value is 0b100100100, so we need some holes in the table.
    pub const CODONS_PER_TABLE: usize = 293;
    // Number of NCBI translation tables (they go up to 33, but there's gaps in the numbering)
    pub const N_TRANS_TABLES: usize = 27;
    pub const LOOKUP_SIZE: usize = Self::CODONS_PER_TABLE * Self::N_TRANS_TABLES;
    /// Generated by bin/gen_table.rs, layout is all codons for table 1, then all codons for table 2, etc.
    const TRANSLATION_TABLES: &'static [u8; Self::LOOKUP_SIZE] = include_bytes!("tables.dat");

    fn table_index(self) -> usize {
        match self {
            // table 8 is an alias for table 1
            Self::Ncbi1 | Self::Ncbi8 => 0,
            Self::Ncbi2 => 1,
            Self::Ncbi3 => 2,
            // table 7 is identical to table 4
            Self::Ncbi4 | Self::Ncbi7 => 3,
            Self::Ncbi5 => 4,
            Self::Ncbi6 => 5,
            Self::Ncbi9 => 6,
            Self::Ncbi10 => 7,
            Self::Ncbi11 => 8,
            Self::Ncbi12 => 9,
            Self::Ncbi13 => 10,
            Self::Ncbi14 => 11,
            Self::Ncbi15 => 12,
            Self::Ncbi16 => 13,
            Self::Ncbi21 => 14,
            Self::Ncbi22 => 15,
            Self::Ncbi23 => 16,
            Self::Ncbi24 => 17,
            Self::Ncbi25 => 18,
            Self::Ncbi26 => 19,
            Self::Ncbi27 => 20,
            Self::Ncbi28 => 21,
            Self::Ncbi29 => 22,
            Self::Ncbi30 => 23,
            Self::Ncbi31 => 24,
            Self::Ncbi32 => 25,
            Self::Ncbi33 => 26,
        }
    }

    pub fn translate_dna_bytes(self, dna: &[u8]) -> Result<Vec<u8>, TranslationError> {
        if dna.is_empty() {
            return Ok(Vec::new());
        }

        let table_idx = self.table_index();

        let mut result = Vec::with_capacity(dna.len() / 3);

        // this will truncate any trailing non-multiple-of-3 chunk
        // biopython also truncates, but warns -- generally I don't think we care,
        // so I just made it silently truncate
        for chunk in dna.chunks_exact(3) {
            let a = chunk[0].try_into()?;
            let b = chunk[1].try_into()?;
            let c = chunk[2].try_into()?;
            let codon_idx = CodonIdx::from([a, b, c]);
            result.push(
                Self::TRANSLATION_TABLES
                    [table_idx * TranslationTable::CODONS_PER_TABLE + usize::from(codon_idx)],
            );
        }

        Ok(result)
    }

    pub fn translate_dna(self, dna: &[Nucleotide]) -> Vec<u8> {
        if dna.is_empty() {
            return Vec::new();
        }

        let table_idx = self.table_index();

        let mut result = Vec::with_capacity(dna.len() / 3);

        // this will truncate any trailing non-multiple-of-3 chunk
        // biopython also truncates, but warns -- generally I don't think we care,
        // so I just made it silently truncate
        for chunk in dna.chunks_exact(3) {
            let sized_chunk: [Nucleotide; 3] = [chunk[0], chunk[1], chunk[2]];
            let codon_idx = CodonIdx::from(sized_chunk);
            result.push(
                Self::TRANSLATION_TABLES
                    [table_idx * TranslationTable::CODONS_PER_TABLE + usize::from(codon_idx)],
            );
        }

        result
    }
}

impl TryFrom<u8> for TranslationTable {
    type Error = TranslationError;

    fn try_from(value: u8) -> Result<Self, Self::Error> {
        match value {
            1 => Ok(Self::Ncbi1),
            2 => Ok(Self::Ncbi2),
            3 => Ok(Self::Ncbi3),
            4 => Ok(Self::Ncbi4),
            5 => Ok(Self::Ncbi5),
            6 => Ok(Self::Ncbi6),
            7 => Ok(Self::Ncbi7),
            8 => Ok(Self::Ncbi8),
            9 => Ok(Self::Ncbi9),
            10 => Ok(Self::Ncbi10),
            11 => Ok(Self::Ncbi11),
            12 => Ok(Self::Ncbi12),
            13 => Ok(Self::Ncbi13),
            14 => Ok(Self::Ncbi14),
            15 => Ok(Self::Ncbi15),
            16 => Ok(Self::Ncbi16),
            21 => Ok(Self::Ncbi21),
            22 => Ok(Self::Ncbi22),
            23 => Ok(Self::Ncbi23),
            24 => Ok(Self::Ncbi24),
            25 => Ok(Self::Ncbi25),
            26 => Ok(Self::Ncbi26),
            27 => Ok(Self::Ncbi27),
            28 => Ok(Self::Ncbi28),
            29 => Ok(Self::Ncbi29),
            30 => Ok(Self::Ncbi30),
            31 => Ok(Self::Ncbi31),
            32 => Ok(Self::Ncbi32),
            33 => Ok(Self::Ncbi33),
            _ => Err(TranslationError::BadTranslationTable(value)),
        }
    }
}

pub fn reverse_complement_bytes(dna: &[u8]) -> Result<Vec<u8>, TranslationError> {
    let mut v = vec![0u8; dna.len()];
    for (i, &b) in dna.iter().enumerate() {
        let n = Nucleotide::try_from(b)?;
        v[dna.len() - 1 - i] = n.complement().to_ascii();
    }
    Ok(v)
}

pub fn reverse_complement(dna: &[Nucleotide]) -> Vec<Nucleotide> {
    let mut v = vec![Nucleotide::N; dna.len()];
    for (i, &n) in dna.iter().enumerate() {
        v[dna.len() - 1 - i] = n.complement();
    }
    v
}
